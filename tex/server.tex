%# -*- coding: utf-8-unix -*-

\chapter{服务端设计与实现}
\label{chap:server}

\section{服务端概要}
\label{sec:serverOverview}

Appetizer服务端的作用主要有三个：

\begin{itemize}
	\item 接收并存储集成了Appetizer客户端SDK的Android应用程序发送的数据
	\item 计算分析接收的数据，得到更有价值的结果
	\item 提供数据给开发者查看
\end{itemize}

其中提供数据给开发者查看，是服务端提供查询API，由另外的客户端调用查询API完成展现数据给开发者的功能，该部分与核心功能关系不大，本篇文章不讨论该部分。本章主要介绍Appetizer服务端如何处理接收集成了Appetizer客户端SDK的Android应用程序发来的数据，简要介绍对数据的处理方法。

\section{服务端架构}
\label{sec:serverArch}

% TODO 图

如 图 所示是服务端架构，服务端主要分为前台（Frontend）和后台（Backend）两部分，其他重要的部分包括数据库和前台后台的通信。

前台、后台、数据库和通信四个部分采用的都是可扩展性良好的设计方案，并且结合每个部分处理的业务定制了专门的解决方案。

\subsection{前台}

前台的主要作用是完成输入输出（IO）密集型业务。包括接收集成了Appetizer客户端SDK的Android应用程序发送的数据，对数据做简单的处理转发给后台，提供查询API供面向开发者的客户端使用。

Appetize服务端的前台（Frontend）部分使用Python 3.5开发，接收Andorid应用程序的数据部分基于asyncio HTTP实现。前台的业务逻辑主要是数据格式处理、时间校准、数据库存储和数据转发到后台，业务逻辑的任务流主要使用 Python 3.5提供的async IO进行分配执行，数据库相关的操作使用第三方库motor实现，motor是一个结合async IO和MongoDB的工具库。

整个前台程序，包括HTTP请求路由、业务逻辑执行、数据库操作都支持Python的异步协程（async）机制，便于写出支持多核的不阻塞异步业务逻辑代码。

\subsection{后台}

后台的主要作用是持久化存储数据和完成计算密集型业务。后台接收前台做过简单处理的数据，持久化存储数据，对数据做增量型数据统计处理，定时做计算量较大的数据处理业务，处理后的数据定时发送给前台共查询API调用。

Appetizer服务端的后台（Backend）部分使用Java 8开发，依赖的第三方库包括ProtocolBuffer、MongoDB Driver和RabbitMQ Client。
后台框架将RabbitMQ通道传来的消息分配到不同的任务执行单元，框架自动将消息内的ProtocolBuffer数据根据描述文件转成MongoDB的BSON（二进制JSON）对象，然后进行增量处理或者定时的全量处理。

定时任务的触发由另一块单独的Python程序完成，定时器同样通过RabbitMQ发送消息触发Appetizer服务端Java后台程序的定时任务，复用Java后台的消息分配机制，并且RabbitMQ生产者消费者模型有断电容错恢复机制，定时器复用消息模型增强了定时任务的稳定性。

\subsection{数据库}

前台和后台的数据库使用的都是MongoDB，因为Appetizer面向的数据都不是简单的用户信息，单个数据都涉及到较为复杂的多级结构，例如Android系统ROM构建信息本身还包含若干信息，直接使用JSON格式存储该信息的内容比较合适，Android系统ROM构建信息本身又是整个崩溃设备实时状态的一部分。因此存储单元为文档（Document）的NoSQL数据库MongoDB作为Appetizer服务端系统的数据库非常合适。

MongoDB的单个文档（Document）最多存4MB的数据，建议低于1MB，部分业务的数据可能大于1MB，例如统计日活跃用户的用户列表信息对于百万级用户量以上的Android应用数据会大于1MB，对于可能发生这种情况的任务，程序逻辑会对文档进行拆分。

\subsection{通信}

前台和后台之间的通信采用RabbitMQ，支持多机与多机之间的生产者消费者模型消息传递。消息的内容使用ProtocolBuffer对象，前台和后台的数据模型可以使用同一份描述文件，为了减少后台Java模型类的代码，后台部分实现了自动从ProtocolBuffer生成的Java模型类到MongoDB使用的BSON格式对象的转换。

采用生产者消费者消息模型的原因是让整个系统架构具有可伸缩性，即使某个时间段来自Android应用程序的消息数量过多，后台相比前台耗时更大，后台的任务不需要立刻反馈，无法处理的消息可以堆积在消息队列中，需要加大处理能力可以简单的增加机器，生产者消费者消息模型保证系统的稳定性和可伸缩性。

\section{服务端实现}

Appetizer的服务端实现偏向具体业务，不是本篇文章介绍的重点，相比于Appetizer客户端SDK的实现内容篇幅更少，主要介绍核心部分。

\subsection{时间校准}

时间校准是前台业务非常重要的预处理部分。集成了Appetizer客户端SDK的Android应用程序收集的数据中的时间信息，如果从远端服务器获取精确的时间存在两个问题，首先是开销太大，所有包含时间的信息都要做至少一个网络输入输出（IO）操作，其次是不能保证所有设备都在网络通畅的环境，因此Appetizer客户端SDK收集的数据从远端服务器获取时间是不可取的，只能从本地设备获取。

虽然真实情况下大部分Android系统ROM都会自动从服务器校准时间，时间比较准确，但Android设备的时间可以由用户自己修改，所以从本地获取的时间对于服务端依然是不可信的，服务端所有的时间信息需要校准到服务器的本地时间，服务器的本地时间是可控的，认为是准确可信的。

Appetizer时间校准的解决办法需要Android客户端SDK配合，对于所有涉及时间的信息，Appetizer客户端SDK在发送到服务端之前会添加发送时的本地时间数据到发送的数据包中，Appetizer服务端前台接收到数据时，服务端当前时间减去数据中发送时间得到差值，认为这个差值是服务端本地时间和Android设备本地时间的差值，再对数据中所有从Android设备获取的时间加上该差值，这样就把所有在Android设备本地获取的时间校准到服务端的时间。时间校准是Appetizer服务端前台为数不多计算量稍大的任务。

该时间校准方法依然存在两个问题：

\begin{enumerate}
	\item Android应用程序发送数据中的发送时间和服务端接收数据的服务端本地时间不是物理世界中的同一时刻，存在网络延迟的时间间隔，该间隔的大小是不确定的。
	\item Android设备可能在一次信息收集过程中记录多个时间节点之间，修改设备本地时间。例如记录用户会话信息时在开始和结束之间修改设备本地时间。
\end{enumerate} 

问题1虽然会影响时间校准的准确性，但是在本篇文章介绍的系统中是可以容忍的。因为需要精确计时的业务都是计算时间间隔，时间校准的精确程度对于时间间隔没有影响。其他需要记录时刻的业务都不需要高精度的计时，可以容忍数秒的时刻偏移。

问题2如果要彻底解决，需要Appetizer客户端SDK监听设备本地时间修改事件，还需要额外的权限。考虑到问题2发生的概率较小，即使发生也不会造成很严重的影响，因此整个系统容忍问题2的存在。

\subsection{日活跃用户统计}



\subsection{崩溃信息存储}


\section{本章小结}

